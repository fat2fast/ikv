package cmd

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"github.com/golang-migrate/migrate/v4"
	_ "github.com/golang-migrate/migrate/v4/database/postgres"
	_ "github.com/golang-migrate/migrate/v4/source/file"
	"gopkg.in/yaml.v3"

	"github.com/spf13/cobra"
)

// RawModuleConfig ƒë·ªÉ ƒë·ªçc config d∆∞·ªõi d·∫°ng strings t·ª´ YAML
type RawModuleConfig struct {
	Module struct {
		Name        string `yaml:"name"`
		Version     string `yaml:"version"`
		Enabled     string `yaml:"enabled"`
		Description string `yaml:"description"`
	} `yaml:"module"`
	Database struct {
		Connection struct {
			Driver     string `yaml:"driver"`
			Host       string `yaml:"host"`
			Port       string `yaml:"port"`
			Database   string `yaml:"database"`
			Username   string `yaml:"username"`
			Password   string `yaml:"password"`
			Schema     string `yaml:"schema"`
			AutoCreate string `yaml:"auto_create"`
			SSLMode    string `yaml:"ssl_mode"`
			Timezone   string `yaml:"timezone"`
		} `yaml:"connection"`
		Migration struct {
			Path   string `yaml:"path"`
			Table  string `yaml:"table"`
			Schema string `yaml:"schema"`
		} `yaml:"migration"`
		Performance struct {
			MaxOpenConns    string `yaml:"max_open_conns"`
			MaxIdleConns    string `yaml:"max_idle_conns"`
			ConnMaxLifetime string `yaml:"conn_max_lifetime"`
		} `yaml:"performance"`
	} `yaml:"database"`
}

// ModuleConfig ƒë·ªãnh nghƒ©a c·∫•u tr√∫c config cho module v·ªõi ƒë√∫ng ki·ªÉu d·ªØ li·ªáu
type ModuleConfig struct {
	Module struct {
		Name        string `yaml:"name"`
		Version     string `yaml:"version"`
		Enabled     bool   `yaml:"enabled"`
		Description string `yaml:"description"`
	} `yaml:"module"`
	Database struct {
		Connection struct {
			Driver     string `yaml:"driver"`
			Host       string `yaml:"host"`
			Port       int    `yaml:"port"`
			Database   string `yaml:"database"`
			Username   string `yaml:"username"`
			Password   string `yaml:"password"`
			Schema     string `yaml:"schema"`
			AutoCreate bool   `yaml:"auto_create"`
			SSLMode    string `yaml:"ssl_mode"`
			Timezone   string `yaml:"timezone"`
		} `yaml:"connection"`
		Migration struct {
			Path   string `yaml:"path"`
			Table  string `yaml:"table"`
			Schema string `yaml:"schema"`
		} `yaml:"migration"`
		Performance struct {
			MaxOpenConns    int    `yaml:"max_open_conns"`
			MaxIdleConns    int    `yaml:"max_idle_conns"`
			ConnMaxLifetime string `yaml:"conn_max_lifetime"`
		} `yaml:"performance"`
	} `yaml:"database"`
}

// expandEnvVar expand m·ªôt environment variable v·ªõi format ${VAR:default}
func expandEnvVar(envStr string) string {
	// N·∫øu kh√¥ng ph·∫£i format ${VAR:default}, tr·∫£ v·ªÅ nh∆∞ c≈©
	if !strings.HasPrefix(envStr, "${") || !strings.HasSuffix(envStr, "}") {
		return envStr
	}

	// Remove ${ v√† }
	content := envStr[2 : len(envStr)-1]

	// Split theo :
	parts := strings.SplitN(content, ":", 2)
	varName := parts[0]
	defaultValue := ""

	if len(parts) > 1 {
		defaultValue = parts[1]
	}

	// L·∫•y gi√° tr·ªã t·ª´ environment
	if value := os.Getenv(varName); value != "" {
		return value
	}

	return defaultValue
}

// convertRawToModuleConfig chuy·ªÉn ƒë·ªïi RawModuleConfig th√†nh ModuleConfig
func convertRawToModuleConfig(raw *RawModuleConfig) (*ModuleConfig, error) {
	config := &ModuleConfig{}

	// Module
	config.Module.Name = raw.Module.Name
	config.Module.Version = raw.Module.Version
	config.Module.Description = raw.Module.Description

	// Parse enabled
	enabledStr := expandEnvVar(raw.Module.Enabled)
	if enabled, err := strconv.ParseBool(enabledStr); err == nil {
		config.Module.Enabled = enabled
	} else {
		config.Module.Enabled = true // default
	}

	// Database Connection
	config.Database.Connection.Driver = expandEnvVar(raw.Database.Connection.Driver)
	config.Database.Connection.Host = expandEnvVar(raw.Database.Connection.Host)
	config.Database.Connection.Database = expandEnvVar(raw.Database.Connection.Database)
	config.Database.Connection.Username = expandEnvVar(raw.Database.Connection.Username)
	config.Database.Connection.Password = expandEnvVar(raw.Database.Connection.Password)
	config.Database.Connection.Schema = expandEnvVar(raw.Database.Connection.Schema)
	config.Database.Connection.SSLMode = expandEnvVar(raw.Database.Connection.SSLMode)
	config.Database.Connection.Timezone = expandEnvVar(raw.Database.Connection.Timezone)

	// Parse port
	portStr := expandEnvVar(raw.Database.Connection.Port)
	if port, err := strconv.Atoi(portStr); err == nil {
		config.Database.Connection.Port = port
	} else {
		config.Database.Connection.Port = 5432 // default
	}

	// Parse auto_create
	autoCreateStr := expandEnvVar(raw.Database.Connection.AutoCreate)
	if autoCreate, err := strconv.ParseBool(autoCreateStr); err == nil {
		config.Database.Connection.AutoCreate = autoCreate
	} else {
		config.Database.Connection.AutoCreate = true // default
	}

	// Database Migration
	config.Database.Migration.Path = expandEnvVar(raw.Database.Migration.Path)
	config.Database.Migration.Table = expandEnvVar(raw.Database.Migration.Table)
	config.Database.Migration.Schema = expandEnvVar(raw.Database.Migration.Schema)

	// Database Performance
	maxOpenConnsStr := expandEnvVar(raw.Database.Performance.MaxOpenConns)
	if maxOpenConns, err := strconv.Atoi(maxOpenConnsStr); err == nil {
		config.Database.Performance.MaxOpenConns = maxOpenConns
	} else {
		config.Database.Performance.MaxOpenConns = 10 // default
	}

	maxIdleConnsStr := expandEnvVar(raw.Database.Performance.MaxIdleConns)
	if maxIdleConns, err := strconv.Atoi(maxIdleConnsStr); err == nil {
		config.Database.Performance.MaxIdleConns = maxIdleConns
	} else {
		config.Database.Performance.MaxIdleConns = 2 // default
	}

	config.Database.Performance.ConnMaxLifetime = expandEnvVar(raw.Database.Performance.ConnMaxLifetime)

	return config, nil
}

// loadModuleConfig load config t·ª´ file config.yaml c·ªßa module
func loadModuleConfig(moduleName string) (*ModuleConfig, error) {
	configPath := filepath.Join("/app/modules", moduleName, "config.yaml")

	// Ki·ªÉm tra file c√≥ t·ªìn t·∫°i kh√¥ng
	if _, err := os.Stat(configPath); os.IsNotExist(err) {
		return nil, fmt.Errorf("config file not found: %s", configPath)
	}

	// ƒê·ªçc file config
	data, err := os.ReadFile(configPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read config file: %v", err)
	}

	// Parse YAML
	var raw RawModuleConfig
	if err := yaml.Unmarshal(data, &raw); err != nil {
		return nil, fmt.Errorf("failed to parse config file: %v", err)
	}

	// Convert RawModuleConfig to ModuleConfig
	config, err := convertRawToModuleConfig(&raw)
	if err != nil {
		return nil, fmt.Errorf("failed to convert raw config to module config: %v", err)
	}

	return config, nil
}

// getDatabaseURL t·∫°o database URL t·ª´ config
func getDatabaseURL(config *ModuleConfig) string {
	return fmt.Sprintf("postgresql://%s:%s@%s:%d/%s?sslmode=%s&search_path=%s",
		config.Database.Connection.Username,
		config.Database.Connection.Password,
		config.Database.Connection.Host,
		config.Database.Connection.Port,
		config.Database.Connection.Database,
		config.Database.Connection.SSLMode,
		config.Database.Connection.Schema,
	)
}

// getMigrationPath l·∫•y ƒë∆∞·ªùng d·∫´n migration t·ª´ config
func getMigrationPath(config *ModuleConfig) string {
	return config.Database.Migration.Path
}

// Migrate command v·ªõi sub commands
var migrateCmd = &cobra.Command{
	Use:   "migrate",
	Short: "Qu·∫£n l√Ω database migrations",
	Long:  "L·ªánh n√†y cung c·∫•p c√°c ch·ª©c nƒÉng ƒë·ªÉ qu·∫£n l√Ω database migrations cho t·ª´ng module",
}

var migrateUpCmd = &cobra.Command{
	Use:   "up",
	Short: "Ch·∫°y migrations",
	Long:  "Ch·∫°y migrations cho module ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh ho·∫∑c t·∫•t c·∫£ modules",
	Run: func(cmd *cobra.Command, args []string) {
		moduleName, _ := cmd.Flags().GetString("module")
		all, _ := cmd.Flags().GetBool("all")

		if all {
			fmt.Println("üöÄ ƒêang ch·∫°y migrations cho t·∫•t c·∫£ modules...")
			// L·∫•y danh s√°ch t·∫•t c·∫£ modules t·ª´ th∆∞ m·ª•c modules
			modules, err := getAvailableModules()
			if err != nil {
				log.Fatalf("L·ªói khi l·∫•y danh s√°ch modules: %v", err)
			}

			for _, module := range modules {
				fmt.Printf("üì¶ Ch·∫°y migration cho module: %s\n", module)
				if err := runMigrationUp(module); err != nil {
					log.Printf("‚ùå L·ªói khi ch·∫°y migration cho module %s: %v", module, err)
					continue
				}
				fmt.Printf("‚úÖ Migration ho√†n th√†nh cho module: %s\n", module)
			}
			fmt.Println("üéâ T·∫•t c·∫£ migrations ƒë√£ ho√†n th√†nh!")
		} else if moduleName != "" {
			fmt.Printf("üöÄ ƒêang ch·∫°y migrations cho module: %s\n", moduleName)
			if err := runMigrationUp(moduleName); err != nil {
				log.Fatalf("‚ùå L·ªói khi ch·∫°y migration: %v", err)
			}
			fmt.Println("‚úÖ Migrations ƒë√£ ho√†n th√†nh!")
		} else {
			fmt.Println("‚ùå Vui l√≤ng ch·ªâ ƒë·ªãnh module v·ªõi --module ho·∫∑c s·ª≠ d·ª•ng --all")
			cmd.Help()
		}
	},
}

var migrateDownCmd = &cobra.Command{
	Use:   "down",
	Short: "Rollback migrations",
	Long:  "Rollback migrations cho module ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh",
	Run: func(cmd *cobra.Command, args []string) {
		moduleName, _ := cmd.Flags().GetString("module")
		steps, _ := cmd.Flags().GetInt("steps")

		if moduleName == "" {
			fmt.Println("‚ùå Vui l√≤ng ch·ªâ ƒë·ªãnh module v·ªõi --module")
			cmd.Help()
			return
		}

		fmt.Printf("üîÑ ƒêang rollback %d migration(s) cho module: %s\n", steps, moduleName)
		if err := runMigrationDown(moduleName, steps); err != nil {
			log.Fatalf("‚ùå L·ªói khi rollback migration: %v", err)
		}
		fmt.Println("‚úÖ Rollback ƒë√£ ho√†n th√†nh!")
	},
}

var migrateCreateCmd = &cobra.Command{
	Use:   "create",
	Short: "T·∫°o migration m·ªõi",
	Long:  "T·∫°o file migration m·ªõi cho module ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh",
	Run: func(cmd *cobra.Command, args []string) {
		moduleName, _ := cmd.Flags().GetString("module")
		migrationName, _ := cmd.Flags().GetString("name")

		if moduleName == "" || migrationName == "" {
			fmt.Println("‚ùå Vui l√≤ng ch·ªâ ƒë·ªãnh module v·ªõi --module v√† t√™n migration v·ªõi --name")
			cmd.Help()
			return
		}

		fmt.Printf("üìù ƒêang t·∫°o migration: %s cho module: %s\n", migrationName, moduleName)
		if err := createMigration(moduleName, migrationName); err != nil {
			log.Fatalf("‚ùå L·ªói khi t·∫°o migration: %v", err)
		}
		fmt.Println("‚úÖ Migration ƒë√£ ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng!")
	},
}

var migrateStatusCmd = &cobra.Command{
	Use:   "status",
	Short: "Ki·ªÉm tra tr·∫°ng th√°i migrations",
	Long:  "Ki·ªÉm tra tr·∫°ng th√°i migrations cho module ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh",
	Run: func(cmd *cobra.Command, args []string) {
		moduleName, _ := cmd.Flags().GetString("module")

		if moduleName == "" {
			fmt.Println("‚ùå Vui l√≤ng ch·ªâ ƒë·ªãnh module v·ªõi --module")
			cmd.Help()
			return
		}

		fmt.Printf("üìä ƒêang ki·ªÉm tra tr·∫°ng th√°i migration cho module: %s\n", moduleName)
		if err := checkMigrationStatus(moduleName); err != nil {
			log.Fatalf("‚ùå L·ªói khi ki·ªÉm tra tr·∫°ng th√°i migration: %v", err)
		}
	},
}

var migratePendingCmd = &cobra.Command{
	Use:   "pending",
	Short: "Hi·ªÉn th·ªã migrations ch∆∞a ƒë∆∞·ª£c apply",
	Long:  "Hi·ªÉn th·ªã danh s√°ch migrations ch∆∞a ƒë∆∞·ª£c apply cho module ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh ho·∫∑c t·∫•t c·∫£ modules",
	Run: func(cmd *cobra.Command, args []string) {
		moduleName, _ := cmd.Flags().GetString("module")
		all, _ := cmd.Flags().GetBool("all")

		if all {
			fmt.Println("üìã ƒêang ki·ªÉm tra pending migrations cho t·∫•t c·∫£ modules...")
			modules, err := getAvailableModules()
			if err != nil {
				log.Fatalf("L·ªói khi l·∫•y danh s√°ch modules: %v", err)
			}

			for _, module := range modules {
				fmt.Printf("\nüì¶ Module: %s\n", module)
				if err := checkPendingMigrations(module); err != nil {
					log.Printf("‚ùå L·ªói khi ki·ªÉm tra pending migrations cho module %s: %v", module, err)
					continue
				}
			}
		} else if moduleName != "" {
			fmt.Printf("üìã ƒêang ki·ªÉm tra pending migrations cho module: %s\n", moduleName)
			if err := checkPendingMigrations(moduleName); err != nil {
				log.Fatalf("‚ùå L·ªói khi ki·ªÉm tra pending migrations: %v", err)
			}
		} else {
			fmt.Println("‚ùå Vui l√≤ng ch·ªâ ƒë·ªãnh module v·ªõi --module ho·∫∑c s·ª≠ d·ª•ng --all")
			cmd.Help()
		}
	},
}

// Helper functions cho migration
func getAvailableModules() ([]string, error) {
	modulesDir := "modules"
	entries, err := os.ReadDir(modulesDir)
	if err != nil {
		return nil, err
	}

	var modules []string
	for _, entry := range entries {
		if entry.IsDir() {
			// Ki·ªÉm tra xem c√≥ file config.yaml kh√¥ng
			configPath := filepath.Join(modulesDir, entry.Name(), "config.yaml")
			if _, err := os.Stat(configPath); err == nil {
				modules = append(modules, entry.Name())
			}
		}
	}
	return modules, nil
}

func runMigrationUp(moduleName string) error {
	config, err := loadModuleConfig(moduleName)
	if err != nil {
		return err
	}

	databaseURL := getDatabaseURL(config)
	migrationPath := getMigrationPath(config)
	fmt.Printf("üìÅ Migration Path: %s\n", migrationPath)

	// T·∫°o th∆∞ m·ª•c migrations n·∫øu ch∆∞a c√≥
	if err := os.MkdirAll(migrationPath, 0755); err != nil {
		return fmt.Errorf("failed to create migration directory: %v", err)
	}

	// T·∫°o migration instance t·ª´ golang-migrate
	sourceURL := fmt.Sprintf("file://%s", migrationPath)
	fmt.Printf("üìÇ Source URL: %s\n", sourceURL)

	m, err := migrate.New(sourceURL, databaseURL)
	if err != nil {
		return fmt.Errorf("failed to create migrate instance: %v", err)
	}
	defer m.Close()

	// L·∫•y version tr∆∞·ªõc khi ch·∫°y migration
	oldVersion, _, err := m.Version()
	var beforeVersion uint = 0
	if err == nil {
		beforeVersion = oldVersion
	}

	// Ch·∫°y migrations l√™n version m·ªõi nh·∫•t
	fmt.Printf("üöÄ ƒêang ch·∫°y migrations cho module: %s\n", moduleName)
	if err := m.Up(); err != nil && err != migrate.ErrNoChange {
		return fmt.Errorf("failed to run migrations: %v", err)
	}

	// L·∫•y version hi·ªán t·∫°i
	version, dirty, err := m.Version()
	if err != nil && err != migrate.ErrNilVersion {
		return fmt.Errorf("failed to get migration version: %v", err)
	}

	if err == migrate.ErrNilVersion {
		fmt.Printf("‚úÖ No migrations found, database is empty\n")
	} else if dirty {
		fmt.Printf("‚ö†Ô∏è Migration version %d is dirty (incomplete)\n", version)
	} else {
		fmt.Printf("‚úÖ Migration completed, current version: %d\n", version)

		// Log c√°c migration files ƒë√£ ƒë∆∞·ª£c apply
		if version > beforeVersion {
			upFiles, err := filepath.Glob(filepath.Join(migrationPath, "*.up.sql"))
			if err == nil {
				fmt.Printf("üìÑ Files ƒë√£ ƒë∆∞·ª£c apply:\n")
				for _, file := range upFiles {
					fileName := filepath.Base(file)
					migrationName := strings.TrimSuffix(fileName, ".up.sql")
					parts := strings.SplitN(migrationName, "_", 2)
					if len(parts) >= 1 {
						if fileVersion, parseErr := strconv.ParseUint(parts[0], 10, 64); parseErr == nil {
							if fileVersion > uint64(beforeVersion) && fileVersion <= uint64(version) {
								fmt.Printf("   ‚úÖ %s\n", migrationName)
							}
						}
					}
				}
			}
		}
	}

	return nil
}

func runMigrationDown(moduleName string, steps int) error {
	config, err := loadModuleConfig(moduleName)
	if err != nil {
		return err
	}

	databaseURL := getDatabaseURL(config)
	migrationPath := getMigrationPath(config)
	fmt.Printf("üìÅ Migration Path: %s\n", migrationPath)
	fmt.Printf("üî¢ Steps to rollback: %d\n", steps)

	// T·∫°o migration instance t·ª´ golang-migrate
	sourceURL := fmt.Sprintf("file://%s", migrationPath)

	m, err := migrate.New(sourceURL, databaseURL)
	if err != nil {
		return fmt.Errorf("failed to create migrate instance: %v", err)
	}
	defer m.Close()

	// L·∫•y version tr∆∞·ªõc khi rollback
	oldVersion, _, err := m.Version()
	var beforeVersion uint = 0
	if err == nil {
		beforeVersion = oldVersion
	}

	// Rollback migrations
	fmt.Printf("üîÑ ƒêang rollback %d migration(s) cho module: %s\n", steps, moduleName)
	if err := m.Steps(-steps); err != nil && err != migrate.ErrNoChange {
		return fmt.Errorf("failed to rollback migrations: %v", err)
	}

	// L·∫•y version hi·ªán t·∫°i
	version, dirty, err := m.Version()
	if err != nil && err != migrate.ErrNilVersion {
		return fmt.Errorf("failed to get migration version: %v", err)
	}

	if err == migrate.ErrNilVersion {
		fmt.Printf("‚úÖ Rollback completed, database is empty\n")
	} else if dirty {
		fmt.Printf("‚ö†Ô∏è Migration version %d is dirty (incomplete)\n", version)
	} else {
		fmt.Printf("‚úÖ Rollback completed, current version: %d\n", version)
	}

	// Log c√°c migration files ƒë√£ ƒë∆∞·ª£c rollback
	if beforeVersion > 0 {
		downFiles, err := filepath.Glob(filepath.Join(migrationPath, "*.down.sql"))
		if err == nil {
			fmt.Printf("üìÑ Files ƒë√£ ƒë∆∞·ª£c rollback:\n")
			for _, file := range downFiles {
				fileName := filepath.Base(file)
				migrationName := strings.TrimSuffix(fileName, ".down.sql")
				parts := strings.SplitN(migrationName, "_", 2)
				if len(parts) >= 1 {
					if fileVersion, parseErr := strconv.ParseUint(parts[0], 10, 64); parseErr == nil {
						var currentVersion uint64 = 0
						if err != migrate.ErrNilVersion {
							currentVersion = uint64(version)
						}
						if fileVersion <= uint64(beforeVersion) && fileVersion > currentVersion {
							fmt.Printf("   üîÑ %s\n", migrationName)
						}
					}
				}
			}
		}
	}

	return nil
}

func createMigration(moduleName, migrationName string) error {
	config, err := loadModuleConfig(moduleName)
	if err != nil {
		return err
	}
	migrationPath := getMigrationPath(config)
	log.Printf("üìÅ Migration Path: %s", migrationPath)

	// T·∫°o th∆∞ m·ª•c migrations n·∫øu ch∆∞a c√≥
	if err := os.MkdirAll(migrationPath, 0755); err != nil {
		return err
	}

	// T·∫°o timestamp cho migration
	timestamp := time.Now().Format("20060102150405")

	upFile := filepath.Join(migrationPath, fmt.Sprintf("%s_%s.up.sql", timestamp, migrationName))
	downFile := filepath.Join(migrationPath, fmt.Sprintf("%s_%s.down.sql", timestamp, migrationName))

	// T·∫°o file up
	upContent := fmt.Sprintf("-- Migration: %s\n-- Created at: %s\n\n-- Write your up migration here\n", migrationName, time.Now().Format("2006-01-02 15:04:05"))
	if err := os.WriteFile(upFile, []byte(upContent), 0644); err != nil {
		return err
	}

	// T·∫°o file down
	downContent := fmt.Sprintf("-- Rollback: %s\n-- Created at: %s\n\n-- Write your down migration here\n", migrationName, time.Now().Format("2006-01-02 15:04:05"))
	if err := os.WriteFile(downFile, []byte(downContent), 0644); err != nil {
		return err
	}

	fmt.Printf("üìÑ ƒê√£ t·∫°o file: %s\n", upFile)
	fmt.Printf("üìÑ ƒê√£ t·∫°o file: %s\n", downFile)

	return nil
}

func checkMigrationStatus(moduleName string) error {
	config, err := loadModuleConfig(moduleName)
	if err != nil {
		return err
	}

	databaseURL := getDatabaseURL(config)
	migrationPath := getMigrationPath(config)

	fmt.Printf("üìÅ Migration Path: %s\n", migrationPath)

	// Ki·ªÉm tra s·ªë l∆∞·ª£ng file migration
	files, err := filepath.Glob(filepath.Join(migrationPath, "*.sql"))
	if err != nil {
		return err
	}

	fmt.Printf("üìä T·ªïng s·ªë file migration: %d\n", len(files))

	// T·∫°o migration instance t·ª´ golang-migrate
	sourceURL := fmt.Sprintf("file://%s", migrationPath)

	m, err := migrate.New(sourceURL, databaseURL)
	if err != nil {
		return fmt.Errorf("failed to create migrate instance: %v", err)
	}
	defer m.Close()

	// L·∫•y version hi·ªán t·∫°i
	version, dirty, err := m.Version()
	if err != nil && err != migrate.ErrNilVersion {
		return fmt.Errorf("failed to get migration version: %v", err)
	}

	if err == migrate.ErrNilVersion {
		fmt.Printf("üìä Database status: No migrations applied yet\n")
		fmt.Printf("üÜï Database is empty, ready for first migration\n")
	} else if dirty {
		fmt.Printf("‚ö†Ô∏è Database status: Migration version %d is dirty (incomplete)\n", version)
		fmt.Printf("üîß You may need to fix this migration manually\n")
	} else {
		fmt.Printf("‚úÖ Database status: Current migration version %d\n", version)
		fmt.Printf("üéØ Database is up to date\n")
	}

	return nil
}

func checkPendingMigrations(moduleName string) error {
	config, err := loadModuleConfig(moduleName)
	if err != nil {
		return err
	}

	databaseURL := getDatabaseURL(config)
	migrationPath := getMigrationPath(config)

	// L·∫•y t·∫•t c·∫£ file migration
	upFiles, err := filepath.Glob(filepath.Join(migrationPath, "*.up.sql"))
	if err != nil {
		return fmt.Errorf("failed to read migration files: %v", err)
	}

	if len(upFiles) == 0 {
		fmt.Printf("üì≠ Kh√¥ng c√≥ migration n√†o trong module: %s\n", moduleName)
		return nil
	}

	// T·∫°o migration instance t·ª´ golang-migrate
	sourceURL := fmt.Sprintf("file://%s", migrationPath)
	m, err := migrate.New(sourceURL, databaseURL)
	if err != nil {
		return fmt.Errorf("failed to create migrate instance: %v", err)
	}
	defer m.Close()

	// L·∫•y version hi·ªán t·∫°i
	currentVersion, dirty, err := m.Version()
	if err != nil && err != migrate.ErrNilVersion {
		return fmt.Errorf("failed to get migration version: %v", err)
	}

	fmt.Printf("üìä T·ªïng s·ªë migration files: %d\n", len(upFiles))

	if err == migrate.ErrNilVersion {
		// Ch∆∞a c√≥ migration n√†o ƒë∆∞·ª£c apply
		fmt.Printf("üÜï T·∫•t c·∫£ %d migrations ƒëang pending (ch∆∞a apply):\n", len(upFiles))
		for _, file := range upFiles {
			fileName := filepath.Base(file)
			migrationName := strings.TrimSuffix(fileName, ".up.sql")
			fmt.Printf("   üìÑ %s\n", migrationName)
		}
		return nil
	}

	if dirty {
		fmt.Printf("‚ö†Ô∏è Database c√≥ dirty migration version %d\n", currentVersion)
		return nil
	}

	// So s√°nh v·ªõi current version ƒë·ªÉ t√¨m pending migrations
	pendingCount := 0
	fmt.Printf("‚úÖ Current applied version: %d\n", currentVersion)
	fmt.Printf("üìã Pending migrations:\n")

	for _, file := range upFiles {
		fileName := filepath.Base(file)
		migrationName := strings.TrimSuffix(fileName, ".up.sql")

		// Extract version t·ª´ t√™n file (format: timestamp_name.up.sql)
		parts := strings.SplitN(migrationName, "_", 2)
		if len(parts) >= 1 {
			if versionStr := parts[0]; len(versionStr) >= 1 {
				// Parse version number
				if version, parseErr := strconv.ParseUint(versionStr, 10, 64); parseErr == nil {
					if version > uint64(currentVersion) {
						fmt.Printf("   üìÑ %s (version: %d)\n", migrationName, version)
						pendingCount++
					}
				}
			}
		}
	}

	if pendingCount == 0 {
		fmt.Printf("‚úÖ Kh√¥ng c√≥ pending migrations. Database ƒë√£ up-to-date!\n")
	} else {
		fmt.Printf("üìä T·ªïng s·ªë pending migrations: %d\n", pendingCount)
	}

	return nil
}

// init function ƒë·ªÉ setup migrate commands
func init() {
	// C·∫•u h√¨nh flags cho migrate commands
	migrateUpCmd.Flags().StringP("module", "m", "", "T√™n module ƒë·ªÉ ch·∫°y migration")
	migrateUpCmd.Flags().BoolP("all", "a", false, "Ch·∫°y migration cho t·∫•t c·∫£ modules")

	migrateDownCmd.Flags().StringP("module", "m", "", "T√™n module ƒë·ªÉ rollback migration")
	migrateDownCmd.Flags().IntP("steps", "s", 1, "S·ªë b∆∞·ªõc rollback")

	migrateCreateCmd.Flags().StringP("module", "m", "", "T√™n module ƒë·ªÉ t·∫°o migration")
	migrateCreateCmd.Flags().StringP("name", "n", "", "T√™n migration")

	migrateStatusCmd.Flags().StringP("module", "m", "", "T√™n module ƒë·ªÉ ki·ªÉm tra tr·∫°ng th√°i")

	migratePendingCmd.Flags().StringP("module", "m", "", "T√™n module ƒë·ªÉ ki·ªÉm tra pending migrations")
	migratePendingCmd.Flags().BoolP("all", "a", false, "Ki·ªÉm tra pending migrations cho t·∫•t c·∫£ modules")

	// Th√™m sub commands v√†o migrate command
	migrateCmd.AddCommand(migrateUpCmd)
	migrateCmd.AddCommand(migrateDownCmd)
	migrateCmd.AddCommand(migrateCreateCmd)
	migrateCmd.AddCommand(migrateStatusCmd)
	migrateCmd.AddCommand(migratePendingCmd)
}
